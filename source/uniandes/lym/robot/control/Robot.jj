/*
Gramatica para el Robot:
Autor: Alejandro Arango
Modificado por: Silvia Takahashi
Modificado por: Juan Pablo Morales.
Agregadas producciones para manejar globos
Modificado por Silvia Takahashi



 **/


options 
{
  
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
	
}
   

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;
 
import java.awt.Point;
import java.io.*;
import java.util.*;

@SuppressWarnings("serial")
public class Robot 
{
  // varNames es un arreglo de Strings que contiene los nombres de las variables
  static ArrayList<String > varNames = new ArrayList<String>();
  // varValues es un HashMap que contiene como llave y como valor Strings
  static HashMap<String, String> varValues = new HashMap<String, String>();
  // procNames es un arreglo de Strings que contiene los nombres de los procedimientos
  static ArrayList<String > procNames = new ArrayList<String>();
  // procParams es un HashMap que contiene como llave el nombre del procedimiento y como valor un arreglo de Strings con los nombres de los parametros
	static HashMap<String, ArrayList<String>> procParams = new HashMap<String, ArrayList<String>>();
  // globalScope es un HashMap que contiene como llave el nombre de la variable y como valor su entero asociado
  static HashMap<String, Integer > globalScope = new HashMap<String, Integer>();
  // procCommands es un HashMap que contiene como llave el nombre de un procedimiento y como valor un hashmap que contiene como llave el nombre del comando y como valor un arreglo de Strings con los parametros del comando
  static HashMap<String, ArrayList<HashMap<String, ArrayList<String>>>> procCommands = new HashMap<String,  ArrayList<HashMap<String, ArrayList<String>>>>();

  // whileProcs es un HashMap que contiene como llave el nombre de un procedimiento y como valor un arreglo de HashMaps que contiene como llave un string y como valor un hashmap que contiene como llave el nombre del comando y como valor un arreglo de Strings con los parametros del comando
  static HashMap<String, ArrayList<ArrayList<HashMap<String, ArrayList<String>>>>> whileProcs = new HashMap<String, ArrayList<ArrayList<HashMap<String, ArrayList<String>>>>>();
  // ifProcs es un HashMap que contiene como llave el nombre de un procedimiento y como valor un arreglo de HashMaps que contienen como llave un string y como valor un arreglo de hashmaps que contiene como llave el tipo de condicion y como valor un arreglo de HashMaps que contienen como llave el comando y como valor un arreglo de Strings con los parametros del comando
  static HashMap<String, ArrayList<HashMap<String, ArrayList<HashMap<String, ArrayList<String>>>>>> ifProcs = new HashMap<String, ArrayList<HashMap<String, ArrayList<HashMap<String, ArrayList<String>>>>>>();
  // repeatProcs es un HashMap que contiene como llave el nombre de un procedimiento y como valor un arreglo de HashMaps que contienen como llave un string y como valor un arreglo de hashmaps que contiene como llave el comando y como valor un arreglo de Strings con los parametros del comando
  static HashMap<String, ArrayList<ArrayList<HashMap<String, ArrayList<String>>>>> repeatProcs = new HashMap<String, ArrayList<ArrayList<HashMap<String, ArrayList<String>>>>>();

  static int ifCounter = 0;
  static int whileCounter = 0;
  static int repeatCounter = 0;

  static HashMap<String, ArrayList<String>> orden = new HashMap<String, ArrayList<String>>();


	private RobotWorldDec world;
	
	
	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;
	}

	public static void main(String args[]) throws ParseException, IOException{
    Robot parser = new Robot(System.in);
    while (true)
    {
      System.out.println("Reading from standard input...");
      System.out.print("Enter an expression:");
      try {
        // limpia los arreglos y los HashMaps
        varNames.clear();
        procNames.clear();
        procParams.clear();
        globalScope.clear();
        procCommands.clear();
        whileProcs.clear();
        ifProcs.clear();
        repeatProcs.clear();
        orden.clear();
        // ejecuta la gramatica
        parser.command(null);
        System.out.println("Programa leido correctamente");
        System.out.println("Variables: " + varNames);
        System.out.println("Procedimientos: " + procNames);
        System.out.println("Parametros: " + procParams);
        System.out.println("Comandos: " + procCommands);
        System.out.println("Variables globales: " + globalScope);
        System.out.println("While: " + whileProcs);
        System.out.println("If: " + ifProcs);
        System.out.println("Repeat: " + repeatProcs);
        System.out.println("Orden: " + orden);
      }
      catch (ParseException e) {
        System.out.println(e.getMessage());
      }
      catch (TokenMgrError e) {
        System.out.println(e.getMessage());
      }
    }
  }

	

	String salida=new String();
}
PARSER_END(Robot)


// Tokens que se ignoran
SKIP:
{
		" "
	|	"\r"
	|	"\t"
	| 	"\n"
}

TOKEN: /*Comandos*/
{

  	< WALK: "walk" >
| 	< JUMP: "jump" >
| 	< JUMPTO: "jumpTo" >
| 	< VEER: "veer" >
| 	< LOOK: "look" >
| 	< DROP: "drop" >
|	< GRAB: "grab" >
| 	< GET: "get" >
| 	< FREE: "free" >
| 	< POP: "pop" >
}

TOKEN: /*Directions */
{
  < AROUND: "around" >
| < LEFT: "left" >
| < RIGHT: "right" >
}

TOKEN: /*Orientations */
{
  < NORTH: "north" >
| < SOUTH: "south" >
| < EAST: "east" >
| < WEST: "west" >
}

TOKEN:/*Walks */
{
  < FRONT: "front" >
| < BACK: "back" >
}


TOKEN: /* Conditions */
{
	< ISFACING: "isfacing" >
|	< ISVALID: "isValid"  >
|	< CANWALK: "canWalk"  >
|	< NOT: "not"  >	
}

TOKEN: /*LOGIC */
{
		< PROG: "PROG" >
	| 	< GORP: "GORP" >
	| 	< PROC: "PROC" >
	|   < CORP: "CORP" >
	|  	< VAR: "VAR" >
}

TOKEN:/*Control structures */
{
  < IF: "if" >
| < ELSE: "else" >
| < WHILE: "while" >
| < FI: "fi" >
| < DO: "do" >
| < OD: "od" >
| < REPEAT: "repeatTimes" >
| < PER: "per" >
| < PICK: "pick" >
}

TOKEN : // Terminales generales
{
    < CONSTANT : (< DIGIT >)+ >
|	< WORD: (< LMINUS > | < LMAYUS >)(< LMINUS > | < LMAYUS > | < DIGIT >)* >
|   < #DIGIT : [ "0"-"9" ] >
|   < #LMINUS : ["a"-"z"] >
|   < #LMAYUS : ["A"-"Z"] >
}


TOKEN: // simbolos
{
	< ASSIGNMENT : ":=" >
|	< PI : "(" >
|	< PD : ")" >
|	< CBL : "{" >
|	< CBR : "}" >
|	< SC : ";" >
|	< CM : "," >
}


// Reglas de la gramatica


// Base de la gramatica


boolean command(Console sistema):
{
  ArrayList<String> localScope = new ArrayList<String>();
  ArrayList<String> ordenLocal = new ArrayList<String>();
  Token t;
}
{
	t=< PROG >
  {
    ArrayList<HashMap<String, ArrayList<String>>> listaMapaComandos = new ArrayList<HashMap<String, ArrayList<String>>>();
    procCommands.put(t.image, listaMapaComandos);
    orden.put(t.image, ordenLocal);

  }
  (varDef())? (procDef())* {
    ifCounter = 0;
    whileCounter = 0;
    repeatCounter = 0;
  }insBlock(localScope, t, false) < GORP >
  {
    String procedimientoActual = t.image;
    
    HashMap<String, Integer> scopeLocal = new HashMap<String, Integer>();

    ejecutarEnOrden(procedimientoActual,scopeLocal ,sistema);


    // for (HashMap<String, ArrayList<String>> proc : this.procCo mmands.get("PROG")) 
    // {//HashCompleto
    //   for (String key : proc.keySet()) 
    //   {//Nombre del procedimiento o variable
    //     System.out.println("--------------");
    //     System.out.println(key); 
    //     ArrayList<String> parametros = proc.get(key);
    //     if (this.procNames.contains(key))
    //       {
    //         System.out.println(key);
    //         System.out.println(parametros);
    //         procExecution(key, parametros, sistema);
            
    //       }
    //       else if (this.varNames.contains(key))
    //       {
    //         //Cosas de variables 
    //         this.varValues.put(key, parametros.get(0));
    //       }
    //     }
    //   }
    return false;
    }
  }

void ejecutarEnOrden(String procedimientoActual, HashMap<String, Integer> scopeLocal , Console sistema):
{}
{
  {
    int proc = 0;
    int ifs = 0;
    int whiles = 0;
    int repeats = 0;
    ArrayList<String> instruccionesAEjecutar = orden.get(procedimientoActual);
    System.out.println("Comenzando a ejecutar el programa " + procedimientoActual);
    System.out.println("Comenzando a ejecutar el programa " + procedimientoActual);
    System.out.println(scopeLocal);
    System.out.println(instruccionesAEjecutar);
    System.out.println("\n");
    // System.out.println("****************");
    // System.out.println(procNames);
    for (String instruccion : instruccionesAEjecutar) {
      // System.out.println(instruccion);
      // System.out.println("************************************");
      switch (instruccion) {
        case "if":
          ArrayList<HashMap<String, ArrayList<String>>> comandosDelIf = ifProcs.get(procedimientoActual).get(ifs).get("if");
          ArrayList<HashMap<String, ArrayList<String>>> comandosDelElse = ifProcs.get(procedimientoActual).get(ifs).get("else");
          HashMap<String, ArrayList<String>> condicion = comandosDelIf.get(0);
          // comandos sin condicion
          List <HashMap<String, ArrayList<String>>> comandosSinCondicion = comandosDelIf.subList(1, comandosDelIf.size());
          System.out.println("Condicion del if: " + condicion);
          System.out.println("Comandos del if: " + comandosSinCondicion);
          System.out.println("Comandos del else: " + comandosDelElse);
          
          ifs++;
          break;
        case "while":
          ArrayList<HashMap<String, ArrayList<String>>> comandosDelWhile = whileProcs.get(procedimientoActual).get(whiles);
          HashMap<String, ArrayList<String>> condicionWhile = comandosDelWhile.get(0);
          List <HashMap<String, ArrayList<String>>> comandosSinCondicionWhile = comandosDelWhile.subList(1, comandosDelWhile.size());
          System.out.println("Condicion del while: " + condicionWhile);
          System.out.println("Comandos del while: " + comandosSinCondicionWhile);
          whiles++;
          break;
        case "repeat":
          ArrayList<HashMap<String, ArrayList<String>>> comandosDelRepeat = repeatProcs.get(procedimientoActual).get(repeats);
          HashMap<String, ArrayList<String>> condicionRepeat = comandosDelRepeat.get(0);
          List <HashMap<String, ArrayList<String>>> comandosSinCondicionRepeat = comandosDelRepeat.subList(1, comandosDelRepeat.size());
          String numeroDeRepeticiones = condicionRepeat.get("repeat").get(0);
          System.out.println("Veces: " + numeroDeRepeticiones);
          System.out.println("Comandos del repeat: " + comandosSinCondicionRepeat);
          repeats++;
          break;
        default:
          ArrayList<String> params = procCommands.get(procedimientoActual).get(proc).get(instruccion);
          // System.out.println("************************************");
          // System.out.println(procNames);
          if (procNames.contains(instruccion)) {
            // ArrayList<String> params = procCommands.get(procedimientoActual).get(proc).get(instruccion);
            System.out.println(instruccion + " " + params);
            scopeLocal.clear();
            ArrayList<String> paramsVariables = procParams.get(instruccion);
            for (int i = 0; i < paramsVariables.size(); i++) {
              scopeLocal.put(paramsVariables.get(i), Integer.parseInt(params.get(i)));
            }
            System.out.println("Scope local: " + scopeLocal);
            ejecutarEnOrden(instruccion, scopeLocal, sistema);
            System.out.println("\n");
          } else if (varNames.contains(instruccion)) {
            varValues.put(instruccion, params.get(0));
            System.out.println(instruccion + " " + params);
            System.out.println("\n");
          } else {
            System.out.println(varNames);
            System.out.println(varValues);
            for (int i = 0; i < params.size(); i++)
            {
              if (varValues.containsKey(params.get(i)))
              {
                params.set(i, varValues.get(params.get(i)));
              } else if (scopeLocal.containsKey(params.get(i)))
              {
                params.set(i, Integer.toString(scopeLocal.get(params.get(i))));
              }
            }
            System.out.println(instruccion + " " + params);
            System.out.println("\n");
            commandExecution(instruccion, params, sistema);
            // ArrayList<String> params = procCommands.get(procedimientoActual).get(proc).get(instruccion);
            // System.out.println(instruccion + " " + params);
            // procExecution(instruccion, params, sistema);
          }
          proc++;
          break;
      }
    }
    System.out.println("************************************");
    System.out.println("\n");
    String indices = proc + " " + ifs + " " + whiles + " " + repeats;
    System.out.println(indices);
    System.out.println("\n");

  }
}


void commandExecution(String commandName, ArrayList<String> params, Console sistema):
{}
{
  {
    String salida = "";
    switch(commandName)
    {
      case "walk":
      {
        System.out.println("Command: Walk");
        System.out.println(params);
        walkExecution(params, sistema);
        break;
      }

      case "jump":
      {
        world.moveForward(Integer.parseInt(params.get(0)), true);
        salida = "Command: MoveForward\n";
        break;
      }
      
      case "jumpTo":
      {
        world.setPostion(Integer.parseInt(params.get(0)), Integer.parseInt(params.get(1)));
        salida = "Command: SetPosition\n";
        break;
      }

      case "veer":
      {
        if (params.get(0) == "right")
        {
          world.turnRight();
          salida = "Command: TurnRight\n";
        }
        else if (params.get(0) == "left")
        {
          world.turnRight();
          world.turnRight();
          salida = "Command: TurnRight \n Command: TurnRight\n";
        }
        else if (params.get(0) == "around")
        {
          world.turnRight();
          world.turnRight();
          world.turnRight();
          salida = "Command: TurnRight\nCommand: TurnRight\nCommand: TurnRight\n";
        }        
        break;
      }

      case "look":
      {
        if (params.get(0) == "north")
        {
          correctOr(0, sistema);
        }
        else if (params.get(0) == "south")
        {
          correctOr(1, sistema);
        }
        else if (params.get(0) == "east")
        {
          correctOr(2, sistema);
        }
        else if (params.get(0) == "west")
        {
          correctOr(3, sistema);
        }
        break;
      }

      case "drop":
      {
        // System.out.println("Command: Drop");
        // System.out.println(params);
        world.putChips(Integer.parseInt(params.get(0)));
        salida = "Command: Put Chips\n";
        break;
      }

      case "grab":
      {
        world.grabBalloons(Integer.parseInt(params.get(0)));
        salida = "Command: GrabBalloons\n";
        break;
      }

      case "get":
      {
        world.pickChips(Integer.parseInt(params.get(0)));
        salida = "Command: PickChips\n";
        break;
      }

      case "free":
      {
        System.out.println("Command: Free");
        System.out.println(params);
        world.putBalloons(Integer.parseInt(params.get(0)));
        salida = "Command: putBalloons\n";
        break;
      }

      case "pop":
      {
        world.popBalloons(Integer.parseInt(params.get(0)));
        salida = "Command: PopBalloons\n";
        break;
      }

    }
    sistema.printOutput(salida);
  }
}


void walkExecution(ArrayList<String> params, Console sistema):
{}
{
  {
    String salida = new String();
    if (params.size() == 1)
    {
      world.moveForward(Integer.parseInt(params.get(0)), false);
      salida = "Command: MoveForward";
    }
    else if (params.size() == 2)
    {
      System.out.println("Command: walk");
      ArrayList<String> dirParams = new ArrayList<String>();
      dirParams.add("front");
      dirParams.add("back");
      dirParams.add("left");
      dirParams.add("right");

      ArrayList<String> orParams = new ArrayList<String>();
      orParams.add("north");
      orParams.add("south");
      orParams.add("east");
      orParams.add("west");

      if (dirParams.contains(params.get(0)))
      {
        System.out.println("Command: walk con direccion" + params.get(0));
        if (params.get(0) == "front")
        {
          world.moveVertically(Integer.parseInt(params.get(1)), false);
        } 
        else if (params.get(0) == "back")
        {
          world.moveVertically(Integer.parseInt(params.get(1))*-1, false);
        }
        else if (params.get(0) == "left")
        {
          world.moveHorizontally(Integer.parseInt(params.get(1))*-1, false);
        }
        else if (params.get(0) == "right")
        {
          world.moveHorizontally(Integer.parseInt(params.get(1)), false);
        }
        salida = "Command: MoveHorizontally";
      }
      else if (orParams.contains(params.get(0)))
      {
        // System.out.println("Command: walk con orientacion" + params.get(0));
        if (params.get(0) == "north")
        {
          correctOr(0, sistema);
          world.moveForward(Integer.parseInt(params.get(1)), false);
        }
        else if (params.get(0).equals("south"))
        {
          correctOr(1, sistema);
          world.moveForward(Integer.parseInt(params.get(1)), false);
        }
        else if (params.get(0) == "east")
        {
          correctOr(2, sistema);
          world.moveForward(Integer.parseInt(params.get(1)), false);
        }
        else if (params.get(0) == "west")
        {
          correctOr(3, sistema);
          world.moveForward(Integer.parseInt(params.get(1)), false);
        }
        salida = "Command: MoveForward\n";
      }
    }
    sistema.printOutput(salida);
  }
}

void correctOr(int direction, Console sistema):
{}
{
  {
    int currentOr = world.getFacing();
    boolean correctOr = (currentOr == direction);
    while (!correctOr)
    {
      world.turnRight();
      correctOr = (world.getFacing() == direction);
      sistema.printOutput("Command: TurnRight\n");
    }
  }
}



    // for (HashMap<String, ArrayList<String>> procMaps: procsList)
    // {
    //   // for (String procName: procMaps.keySet())
    //   // {
    //   //   System.out.prinln(procName)
    //   // }
    // }
    
    // MANU - Aqui se debe de empezar a ejecutar el programa
    // MANU - se recorre la lista de comandos del procedimiento principal ("PROG") en el HashMap procCommands.
    // MANU - Te Quiero <3



/*
 * Definicion de variables
 * linea inicial de la forma: VAR <listaDeVariables> SC
 * listaDeVariables de la forma: WORD (CM WORD)*
 * ejemplo: VAR x, y, z;
 */

void varDef():
{
}
{
	< VAR > saveGlobalNamesxType("VAR")( < CM > saveGlobalNamesxType("VAR"))* < SC >
}

/*
 * Guarda los nombres de las variables y los parametros de los procedimientos
 * en sus respectivos HashMaps y arreglos
 * @param type: tipo de variable o procedimiento (VAR o PROC)
 * return: un token que contiene el nombre de la variable o procedimiento
 */

Token saveGlobalNamesxType(String type):
{
  Token t;
}
{
	t = < WORD >
	{
	 	if (type == "VAR"){ 
	  		varNames.add(t.image);
	 	} else if (type == "PROC"){
	 	  	procNames.add(t.image);
        procParams.put(t.image, new ArrayList<String>());
	 	}
	 	return t;
	}
}

/*
 * Guarda las variables locales de un procedimiento en su respectivo HashMap
 * @param localScope: arreglo que contiene las variables locales del procedimiento
 * @param procName: nombre del procedimiento.
 * return: un token que contiene el nombre de la variable
 */

Token saveLocalNamesxType(ArrayList <String > localScope, String procN): /*Arreglar*/
{
  Token t;
}
{
	t = < WORD >
	{
		localScope.add(t.image);
    procParams.get(procN).add(t.image);
    return t;
	}
}

/*
 * Definicion de procedimientos
 * ejemplos:
 *  PROC procName (param1, param2) { ... }
 *  PROC procName () { ... }
 * return: un token que contiene el nombre del procedimiento
 */

void procDef():
{
	ArrayList <String > localScope = new ArrayList<String>();
	Token scope;
  boolean execute = false;
  // Arraylist que contiene hashmaps donde la llave es el nombre del comando y el valor es un arreglo con los parametros
  ArrayList<HashMap<String, ArrayList<String>>> listaMapaComandos = new ArrayList<HashMap<String, ArrayList<String>>>();
  ifCounter = 0;
  whileCounter = 0;
  repeatCounter = 0;
}
{
	< PROC > scope=saveGlobalNamesxType("PROC")
  {
	  // System.out.println(scope.image);
	  // System.out.println(localScope);
    procCommands.put(scope.image, listaMapaComandos);
    orden.put(scope.image, new ArrayList<String>());
	}
  < PI > (saveLocalNamesxType(localScope, scope.image) (< CM > saveLocalNamesxType(localScope, scope.image))*)? < PD >
	insBlock(localScope, scope, execute) < CORP >

}

/*
 * Bloque de instrucciones
 * ejemplo:
 *  {
 *  drop(c);
 *  free (b);
 *  walk(n);
 *  drop(  12)
 *  }
 * @param localScope: arreglo que contiene las variables locales del procedimiento
 * @param scope: token que contiene el nombre del procedimiento
 * @param execute: booleano que indica si el procedimiento se ejecuta o no
 */

void insBlock(ArrayList <String> localScope, Token scope, boolean execute):
{
  String estructura = "procedure";
  ArrayList<HashMap<String, ArrayList<String>>> listaMapaComandos = new ArrayList<HashMap<String, ArrayList<String>>>();
}
{
  < CBL > globalCommand(localScope, scope, execute, estructura) < CBR >
  {
    if (scope.image == "PROG") {
      procCommands.put(scope.image, listaMapaComandos);
    }
  }
}

/*
 * Reglas personalizadas para los procedimientos definidos por el usuario
 * Verifican que el procedimiento exista y que los parametros sean correctos
 *
 * @param localScope: arreglo que contiene las variables locales del procedimiento
 * @param scope: token que contiene el nombre del procedimiento
 * @param execute : booleano que indica si el procedimiento se ejecuta o no
 * return: String que contiene el nombre del procedimiento
 */

String rules(ArrayList <String> localScope, Token scope, boolean execute, String estructura):
{
  Token t;
  Token p;
  ArrayList <String> params = new ArrayList<String>();
}
{
  t= < WORD > < PI > (p=parameter(localScope, true)
  {
    params.add(p.image);
  }
  (< CM > p=parameter(localScope, true)
  {
    params.add(p.image);
  })* )? < PD >
  {
    if (procNames.contains(t.image)){
      if (procParams.get(t.image).size() == params.size()){
        if (!execute){
          guardarInfo(t.image, params, scope, estructura);
        }
        // System.out.println("Correcto");
      } else {
        System.out.println("Incorrecto, cantidad de parametros");
        // raise error
      }
    } else {
      System.out.println("Incorrecto, no existe el procedimiento");
      // 
    }
    return t.image;
  }
}

/*
 * GlobalCommand:
 * Reglas para los comandos en el bloque de instrucciones.
 * Verifica que el comando exista y que los parametros sean correctos,
 * ademas de agregar los comandos a la lista de comandos del procedimiento.
 *
 * @param localScope: arreglo que contiene las variables locales del procedimiento
 * @param scope: token que contiene el nombre del procedimiento
 * @param execute: booleano que indica si el procedimiento se ejecuta o no
 */

void globalCommand(ArrayList <String > localScope, Token scope, boolean execute, String estructura):
{
}
{
	theCommands(localScope, scope, execute, estructura)(< SC > theCommands(localScope, scope ,execute, estructura))*
}

/*
 * Command:
 * Reglas para los comandos en el bloque de instrucciones.
 * Verifica que el comando exista y que los parametros sean correctos.
 * el comando se ejecuta si el procedimiento se ejecuta.
 *
 * @param localScope: arreglo que contiene las variables locales del procedimiento
 * @param scope: token que contiene el nombre del procedimiento
 * @param execute: booleano que indica si el procedimiento se ejecuta o no
 * return: String que contiene el nombre del comando
 */

void theCommands(ArrayList <String > localScope, Token scope ,boolean execute, String estructura):
{
}
{
  (
  posibleCommands(localScope, scope, execute, estructura)
  | jumpTo(localScope, scope, execute, estructura)
  | veer(scope, execute, estructura)
  | look(scope, execute, estructura)
  | walk(localScope, scope, execute, estructura)
  |
  (
  LOOKAHEAD(2)
  assignment(localScope, scope, true, estructura)
  | rules(localScope, scope, execute, estructura)
  )
  | ifBlock(localScope, scope, execute)
  | whileBlock(localScope, scope, execute)
  | repeatBlock(localScope, scope, execute)
  )
}

/*
 * PosibleCommands:
 *
 * Agrupa los comandos que requieren de un parametro de tipo entero.
 *
 * @param localScope: arreglo que contiene las variables locales del procedimiento
 * @param scope: token que contiene el nombre del procedimiento
 * @param execute: booleano que indica si el procedimiento se ejecuta o no
 * return: String que contiene el nombre del comando
 */

void guardarInfo(String t, ArrayList <String> params, Token scope, String estructura):
{}
{
  {
    HashMap <String, ArrayList<String>> hashmapComandos = new HashMap<String, ArrayList<String>>();
    hashmapComandos.put(t, params);
    // separar string estructura por comas
    String [] estructuraArray = estructura.split(",");
    estructura = estructuraArray[0];
    int index = -1;
    try{
      index = Integer.parseInt(estructuraArray[1]);
    } catch (Exception e){
      // System.out.println("Error en el indice");
    }
    switch (estructura){
      case "procedure":
        hashmapComandos.put(t, params);
        procCommands.get(scope.image).add(hashmapComandos);
        orden.get(scope.image).add(t);
        break;
      case "if":
        if (ifProcs.get(scope.image) == null){
          ifProcs.put(scope.image, new ArrayList<HashMap<String,ArrayList<HashMap<String, ArrayList<String>>>>>());
          ifProcs.get(scope.image).add(new HashMap<String,ArrayList<HashMap<String, ArrayList<String>>>>());
          ArrayList<HashMap<String, ArrayList<String>>> temp = new ArrayList<HashMap<String, ArrayList<String>>>();
          temp.add(hashmapComandos);
          ifProcs.get(scope.image).get(index).put("if", temp);
          orden.get(scope.image).add(estructura);
          // System.out.println(ifProcs.get(scope.image).get(index));
        } else if (ifProcs.get(scope.image).size() <= index){
          ifProcs.get(scope.image).add(new HashMap<String,ArrayList<HashMap<String, ArrayList<String>>>>());
          ArrayList<HashMap<String, ArrayList<String>>> temp = new ArrayList<HashMap<String, ArrayList<String>>>();
          temp.add(hashmapComandos);
          ifProcs.get(scope.image).get(index).put("if", temp);
          orden.get(scope.image).add(estructura);
          // System.out.println(ifProcs.get(scope.image).get(index));
        } else {
          ifProcs.get(scope.image).get(index).get("if").add(hashmapComandos);
          // System.out.println(ifProcs.get(scope.image).get(index));
        }
        break;
      case "else":
        if (ifProcs.get(scope.image) == null){
          ifProcs.put(scope.image, new ArrayList<HashMap<String,ArrayList<HashMap<String, ArrayList<String>>>>>());
          ifProcs.get(scope.image).add(new HashMap<String,ArrayList<HashMap<String, ArrayList<String>>>>());
          ArrayList<HashMap<String, ArrayList<String>>> temp = new ArrayList<HashMap<String, ArrayList<String>>>();
          temp.add(hashmapComandos);
          ifProcs.get(scope.image).get(index).put("else", temp);
          // System.out.println(ifProcs.get(scope.image).get(index));
        } else if (ifProcs.get(scope.image).size() <= index){
          ifProcs.get(scope.image).add(new HashMap<String,ArrayList<HashMap<String, ArrayList<String>>>>());
          ArrayList<HashMap<String, ArrayList<String>>> temp = new ArrayList<HashMap<String, ArrayList<String>>>();
          temp.add(hashmapComandos);
          ifProcs.get(scope.image).get(index).put("else", temp);
          // System.out.println(ifProcs.get(scope.image).get(index));
        } else if (ifProcs.get(scope.image).get(index).get("else") == null){
          ArrayList<HashMap<String, ArrayList<String>>> temp = new ArrayList<HashMap<String, ArrayList<String>>>();
          temp.add(hashmapComandos);
          ifProcs.get(scope.image).get(index).put("else", temp);
          // System.out.println(ifProcs.get(scope.image).get(index));
        } else {
          ifProcs.get(scope.image).get(index).get("else").add(hashmapComandos);
          // System.out.println(ifProcs.get(scope.image).get(index));
        }
        break;
      case "while":
        if (whileProcs.get(scope.image) == null){
          whileProcs.put(scope.image, new ArrayList<ArrayList<HashMap<String, ArrayList<String>>>>());
          whileProcs.get(scope.image).add(new ArrayList<HashMap<String, ArrayList<String>>>());
          whileProcs.get(scope.image).get(index).add(hashmapComandos);
          orden.get(scope.image).add(estructura);
          // System.out.println(whileProcs.get(scope.image).get(index));
        } else if (whileProcs.get(scope.image).size() <= index){
          whileProcs.get(scope.image).add(new ArrayList<HashMap<String, ArrayList<String>>>());
          whileProcs.get(scope.image).get(index).add(hashmapComandos);
          orden.get(scope.image).add(estructura);
          // System.out.println(whileProcs.get(scope.image).get(index));
        } else {
          whileProcs.get(scope.image).get(index).add(hashmapComandos);
          // System.out.println(whileProcs.get(scope.image).get(index));
        }
        break;
      case "repeat":
        if (repeatProcs.get(scope.image) == null){
          repeatProcs.put(scope.image, new ArrayList<ArrayList<HashMap<String, ArrayList<String>>>>());
          repeatProcs.get(scope.image).add(new ArrayList<HashMap<String, ArrayList<String>>>());
          repeatProcs.get(scope.image).get(index).add(hashmapComandos);
          orden.get(scope.image).add(estructura);
          // System.out.println(repeatProcs.get(scope.image).get(index));
        } else if (repeatProcs.get(scope.image).size() <= index){
          repeatProcs.get(scope.image).add(new ArrayList<HashMap<String, ArrayList<String>>>());
          repeatProcs.get(scope.image).get(index).add(hashmapComandos);
          orden.get(scope.image).add(estructura);
          // System.out.println(repeatProcs.get(scope.image).get(index));
        } else {
          repeatProcs.get(scope.image).get(index).add(hashmapComandos);
          // System.out.println(repeatProcs.get(scope.image).get(index));
        }
        break;
    }
  }
}

void posibleCommands(ArrayList <String > localScope, Token scope, boolean execute, String estructura):
{
  Token t;
  // hashmap que contiene como llave el nombre del comando y como valor un arreglo con los parametros
  ArrayList <String> params = new ArrayList<String>();
  Token p;
}
{
  (
    t=< DROP > | t=< GRAB > | t=< GET > | t=< FREE > | t=< POP >
  )
  < PI > p=parameter(localScope, true) < PD >
  {
    if (execute){
      System.out.println(t.image + " " + p.image);
    } else {
      // switch estructura
      params.add(p.image);

      guardarInfo(t.image, params, scope, estructura);
      // System.out.println("Comando: " + t.image + " Parametro: " + p.image);
      // System.out.println(hashmapComandos);
      // System.out.println(scope.image);
      // System.out.println("Comandos del procedimiento: " + procCommands.get(scope.image));
      // System.out.println("Comandos del if: " + ifProcs.get(scope.image));
      // System.out.println("Comandos del while: " + whileProcs.get(scope.image));
      // System.out.println("Comandos del repeat: " + repeatProcs.get(scope.image));
      // System.out.println("***************************");
      }


    
  }
}

/*
 * parameter:
 * Reglas para los parametros de los comandos.
 * Verifica que el parametro sea correcto.
 * Si el parametro es una variable, verifica que exista.
 * Si el parametro es un entero, verifica que sea un entero y que el comando acepte enteros (allowInt).
 *
 * @param localScope: arreglo que contiene las variables locales del procedimiento
 * @param allowInt: booleano que indica si el parametro puede ser un entero
 * return: Token que contiene el parametro
 */

Token parameter(ArrayList <String > localScope, boolean allowInt):
{
  Token t;
  Token d;
}
{
  t = < WORD >
  {
    if (localScope.contains(t.image) || varNames.contains(t.image) || globalScope.containsKey(t.image)){
      // System.out.println("OK");
      // System.out.println(t.image);
      return t;
    } else {
      System.out.println("NOK");
      System.out.println(t.image);
    }
  }
  | d = < CONSTANT >
  {
    if (allowInt){
      // System.out.println("OK");
      // System.out.println(d.image);
      return d;
    } else {
      System.out.println("NOK");
      System.out.println(d.image);
    }
  }
}


/*
 * jumpTo:
 * Reglas para el comando jumpTo.
 * 
 * @param localScope: arreglo que contiene las variables locales del procedimiento
 * @param scope: token que contiene el nombre del procedimiento
 * @param execute: booleano que indica si el procedimiento se ejecuta o no
 * return: String que contiene el nombre del comando (jumpTo)
 */

void jumpTo(ArrayList <String > localScope, Token scope, boolean execute, String estructura):
{
  Token t;
  Token p1;
  Token p2;
  // hashmap que contiene como llave el nombre del comando y como valor un arreglo con los parametros
  HashMap <String, ArrayList<String>> hashmapComandos = new HashMap<String, ArrayList<String>>();
  ArrayList <String> params = new ArrayList<String>();
}
{
  t=< JUMPTO > < PI > p1=parameter(localScope, true) < CM > p2=parameter(localScope, true) < PD >
  {
    if (execute){
      System.out.println(t.image + " " + p1.image + " " + p2.image);
    } else {
      params.add(p1.image);
      params.add(p2.image);
      guardarInfo(t.image, params, scope, estructura);
    }
  }
}

/*
 * posibleDirections:
 * Lista de direcciones posibles para el comando veer.
 */

Token posibleDirections():
{
  Token t;
}
{
  (t=< AROUND > | t=< LEFT > | t=< RIGHT >)
  {
    return t;
  }
}

/*
 * posibleOrientations:
 * Lista de orientaciones posibles para el comando look o walk.
 */


// posibleOrientations with return of token
Token posibleOrientations():
{
  Token t;
}
{
  (t=< NORTH > | t=< SOUTH > | t=< EAST > | t=< WEST >)
  {
    return t;
  }
}


/*
 * posibleWalks:
 * Lista de direcciones posibles para el comando walk.
 */

// posibleWalks with return of token

Token posibleWalks():
{
  Token t;
}

{
  (t=< FRONT > | t=< BACK > | t=< LEFT > | t=< RIGHT >)
  {
    return t;
  }
}

/*
 * veer:
 * Reglas para el comando veer.
 *
 * return: String que contiene el nombre del comando (veer)
 */

void veer(Token scope, boolean execute, String estructura):
{
  Token t;
  Token d;
  // hashmap que contiene como llave el nombre del comando y como valor un arreglo con los parametros
  HashMap <String, ArrayList<String>> hashmapComandos = new HashMap<String, ArrayList<String>>();
  ArrayList <String> params = new ArrayList<String>();
}
{
  t=< VEER > < PI > d=posibleDirections() < PD >
  {
    if (execute){
      System.out.println(t.image + " " + d.image);
    } else {
      params.add(d.image);
      guardarInfo(t.image, params, scope, estructura);
    }
  }
}

/*
 * look:
 * Reglas para el comando look.
 *
 * return: String que contiene el nombre del comando (look)
 */
void look(Token scope, boolean execute, String estructura):
{
  Token t;
  Token o;
  // hashmap que contiene como llave el nombre del comando y como valor un arreglo con los parametros
  HashMap <String, ArrayList<String>> hashmapComandos = new HashMap<String, ArrayList<String>>();
  ArrayList <String> params = new ArrayList<String>();
}
{
  t=< LOOK > < PI > o=posibleOrientations() < PD >
  {
    if (execute){
      System.out.println(t.image + " " + o.image);
    } else {
      params.add(o.image);
      guardarInfo(t.image, params, scope, estructura);
    }
  }
}

/*
 * walk:
 * Reglas para el comando walk.
 * 
 * @param localScope: arreglo que contiene las variables locales del procedimiento
 * @param scope: token que contiene el nombre del procedimiento
 * @param execute: booleano que indica si el procedimiento se ejecuta o no
 * 
 * return: String que contiene el nombre del comando (walk)
 */


void walk(ArrayList <String > localScope, Token scope, boolean execute, String estructura):
{

}
{
  < WALK > < PI > walksTypes(localScope, scope, execute, estructura) < PD >
}

/*
 * walksTypes:
 * Agrupa las variantes del comando walk segun los parametros.
 * 
 * @param localScope: arreglo que contiene las variables locales del procedimiento
 * @param scope: token que contiene el nombre del procedimiento
 * @param execute: booleano que indica si el procedimiento se ejecuta o no
 * 
 */

void walksTypes(ArrayList <String > localScope, Token scope, boolean execute, String estructura):
{
  String walk = "walk";
  // hashmap que contiene como llave el nombre del comando y como valor un arreglo con los parametros
  HashMap <String, ArrayList<String>> hashmapComandos = new HashMap<String, ArrayList<String>>();
  ArrayList <String> params = new ArrayList<String>();
  Token p1;
  Token p2;
}
{
  (p1=parameter(localScope, true)
  | p1=posibleWalks() < CM > p2=parameter(localScope, true){
    params.add(p2.image);
  }
  | p1=posibleOrientations() < CM > p2=parameter(localScope, true)
  {
    params.add(p2.image);
  })
  {
    if (execute){
      System.out.println(walk + " " + params);
    } else {
      params.add(0, p1.image);
      guardarInfo(walk, params, scope, estructura);
    }
  }
}

/*
 * assignmment:
 * Reglas para el comando de asignacion.
 * 
 * @param localScope: arreglo que contiene las variables locales del procedimiento
 * @param scope: token que contiene el nombre del procedimiento
 * @param execute: booleano que indica si el procedimiento se ejecuta o no
 * 
 * return: String que contiene el nombre de la variable
 */

void assignment(ArrayList <String > localScope, Token scope, boolean execute, String estructura):
{
  Token t;
  Token n;
  HashMap <String, ArrayList<String>> hashmapComandos = new HashMap<String, ArrayList<String>>();
  ArrayList <String> params = new ArrayList<String>();
}
{
  t=parameter(localScope, false) < ASSIGNMENT > n=< CONSTANT >
  {
    if (execute){
      params.add(n.image);
      guardarInfo(t.image, params, scope, estructura);
      if (localScope.contains(t.image)){
        localScope.set(localScope.indexOf(t.image), n.image);
      } else if (varNames.contains(t.image)){
        globalScope.put(t.image, Integer.parseInt(n.image));
      } else {
        System.out.println("Variable no declarada:" + t.image);
      }
    } else {
      params.add(n.image);
      guardarInfo(t.image, params, scope, estructura);
    }
  }
}

/*
 * terminalBlock:
 * Agrupa los comandos terminales para ser utilizados en las estructuras de control.
 *
 * @param localScope: arreglo que contiene las variables locales del procedimiento
 * @param scope: token que contiene el nombre del procedimiento
 * @param execute: booleano que indica si el procedimiento se ejecuta o no
 */

void terminalBlock(ArrayList <String > localScope, Token scope, boolean execute, String estructura):
{}
{
  < CBL > globalCommand(localScope, scope,execute, estructura) < CBR >
}

/*
 * validList:
 * Agrupa los comandos validos para ser utilizados por la condicion isValid de las estructuras de control.
 */

Token validList():
{
  Token t;
}
{
  (t=< WALK >
  | t=< JUMP >
  | t=< GRAB >
  | t=< DROP >
  | t=< PICK >
  | t=< FREE >
  | t=< POP >)
  {
    return t;
  }
}

/*
 * isFacing:
 * Reglas para la condicion isFacing.
 */

void isFacing(Token scope, boolean execute, String estructura, boolean not):
{
  Token t;
  Token o;
  HashMap <String, ArrayList<String>> hashmapComandos = new HashMap<String, ArrayList<String>>();
  ArrayList <String> params = new ArrayList<String>();
}
{
  t=< ISFACING > < PI > o=posibleOrientations() < PD >
  {
    String condition = t.image;
    if (not){
      condition = "not " + condition;
    }
    if (execute){
      System.out.println(condition + " " + o.image);
    } else {
      params.add(o.image);
      guardarInfo(condition, params, scope, estructura);
    }
  }
}


// por favor documentar el resto de las reglas

void isValid(ArrayList <String > localScope, Token scope, boolean execute, String estructura, boolean not):
{
  Token t;
  Token o;
  HashMap <String, ArrayList<String>> hashmapComandos = new HashMap<String, ArrayList<String>>();
  ArrayList <String> params = new ArrayList<String>();
  Token d;
}
{
  t=< ISVALID > < PI > o=validList() < CM > d=parameter(localScope, true) < PD >
  {
    String condition = t.image;
    if (not){
      condition = "not"+t.image;
    }
    if (execute){
      System.out.println(condition + " " + o.image + " " + d.image);
    } else {
      params.add(o.image);
      params.add(d.image);
      guardarInfo(condition, params, scope, estructura);
    }
  }
}

void canWalk(ArrayList <String > localScope, Token scope, boolean execute, String estructura, boolean not):
{
  Token t;
  Token o;
  Token d;
  HashMap <String, ArrayList<String>> hashmapComandos = new HashMap<String, ArrayList<String>>();
  ArrayList <String> params = new ArrayList<String>();
}
{
  t=< CANWALK > < PI > (o=posibleOrientations()| o=posibleWalks()) < CM > d=parameter(localScope, true) < PD >
  {
    String condition = t.image;
    if (not){
      condition = "not"+t.image;
    }
    if (execute){
      System.out.println(condition + " " + o.image + " " + d.image);
    } else {
      params.add(o.image);
      params.add(d.image);
      guardarInfo(condition, params, scope, estructura);
    }
  }
}

void condition(ArrayList <String > localScope, Token scope, boolean execute, String estructura, boolean not):
{}
{
  isFacing(scope, execute, estructura, not)
  | isValid(localScope, scope,execute, estructura, not)
  | canWalk(localScope, scope,execute, estructura, not)
}

void not(ArrayList <String > localScope, Token scope, boolean execute, String estructura):
{}
{
  < NOT > < PI > condition(localScope, scope,execute, estructura, true) < PD >
}

void ifBlock(ArrayList <String > localScope, Token scope, boolean execute):
{
  Token t;
  String estructura = "if";
  int index = ifCounter;
  estructura += ","+index;
  // System.out.println("if");
  String elseIndex = "else";
  elseIndex += ","+index;
  ifCounter++;
}
{
  < IF > < PI > (not(localScope, scope, execute, estructura) | condition(localScope, scope, execute, estructura, false)) < PD > terminalBlock(localScope, scope, execute, estructura) ( < ELSE >terminalBlock(localScope, scope, execute, elseIndex) )? < FI >

}

void whileBlock(ArrayList <String> localScope, Token scope, boolean execute):
{
  Token t;
  String estructura = "while";
  int index = whileCounter;
  estructura += ","+index;
  // System.out.println("while");
  whileCounter++;
}
{
  <WHILE > < PI > ( not(localScope, scope, execute, estructura) | condition(localScope, scope, execute, estructura, false)) < PD > < DO > terminalBlock(localScope, scope, execute, estructura) < OD >
}

void repeatBlock(ArrayList <String> localScope, Token scope, boolean execute):
{
  Token t;
  String estructura="repeat";
  int index = repeatCounter;
  estructura += ","+index;
  // System.out.println("repeat");
  repeatCounter++;
  Token n;
}
{
  < REPEAT >
  n=parameter(localScope, true) {
    if (!execute){
      ArrayList <String> params = new ArrayList<String>();
      params.add(n.image);
      guardarInfo("repeat", params, scope, estructura);
    }
  } terminalBlock(localScope, scope, execute, estructura) < PER >
  {
    if (execute){
      System.out.println("repeat " + n.image);
    }
  }
}
	//boolean command(uniandes.lym.robot.view.Console sistema) :
//	boolean command(Console sistema):
//	{	
//		
//		int x,y;
//		salida=new String();	
//	}
//
//	
//	{
//		(
//		  (
//		   <RIGHT> "(" ")" {world.turnRight();salida = "Command: Turnright";}
//		| 	<MOV>  "(" x=num() ")" {world.moveForward(x,false);salida = "Command: Moveforward ";}  
//		| 	<HOP>  "(" x=num() ")" {world.moveForward(x,true);salida = "Command:Jumpforward ";}
//		| 	<GO>  "(" x=num() "," y=num()")" {world.setPostion(x,y);salida = "Command:GO ";}  
//		|  <PUT> "("  put() ")"					  			
//		|  <PICK> "(" get()  ")"	
//	    |  < POP > "(" x=num() ")" {world.popBalloons(x); salida = "Comando:  Pop";}
//		) ";" 
//
//		{
//		    try {
//	    			 Thread.sleep(900);
//	    	    } catch (InterruptedException e) {
//	    			        System.err.format("IOException: %s%n", e);
//	    		    }
//	    			 
//			System.out.println(salida);
//			return true;
//		})+
//
//    	| <EOF> {return false;} 
//	}
//
//	void put() :
//	{
//		int f=1;	
//	}
//	{
//		( <CHIPS>    "," f=num() {world.putChips(f); salida = "Command:  Put Chips"; })
//		|  	  ( <BALLOONS>   "," f=num() {world.putBalloons(f); salida = "Command:  Put Balloons";})	 
//
//	}
//
//	void get() :
//	{
//		int f=1;	
//	}
//	{
//		( <CHIPS>   "," f=num() {world.pickChips(f);salida = "Command:  Pick chips";})
//		|  	  ( <BALLOONS>   "," f=num() {world.grabBalloons(f);salida="Command:  Pick balloons";})	 
//
//	}
//
//	
//	
//
//	/**
//	 * Unsigned decimal number
//	 * @return the corresponding value of the string
//	 * @error  corresponding value is too large
//	 */
//
//	int num() throws Error:
//	{	
//		int total=1;
//	}
//	{
//		<NUM>
//		{
//			try 
//			{
//				total = Integer.parseInt(token.image);
//			} 
//			catch (NumberFormatException ee) 
//			{
//				throw new Error("Number out of bounds: "+token.image+" !!");
//			}
//			return total;
//		}
//	}

	